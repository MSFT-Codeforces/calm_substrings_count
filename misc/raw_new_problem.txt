## Problem — Count Diverse Substrings

You are given a string \(s\) of length \(n\) consisting of lowercase Latin letters.

A string of length \(m\) is called **diverse** if **no** letter appears **strictly more than** \(\frac{m}{2}\) times in it.

A **substring** of \(s\) is a contiguous segment of characters of \(s\).

### Task
Compute the **number of diverse substrings** of \(s\).

---

### Input Format
- The first line contains an integer \(n\) \((1 \le n \le 2\cdot 10^5)\) — the length of the string.
- The second line contains the string \(s\) of length \(n\), consisting of lowercase Latin letters.

### Output Format
Print one integer — the number of diverse substrings of \(s\).

---

### Examples

Input
```
2
ab
```
Output
```
1
```

Input
```
4
aaaa
```
Output
```
0
```

Input
```
3
aab
```
Output
```
1
```

---

## Editorial

A substring of length \(m\) is **not** diverse iff there exists a letter whose frequency is \(> \frac{m}{2}\). Such a letter is a **strict majority**.

### 1) Uniqueness of strict majority
A substring cannot have two different strict majority letters. If letters \(x\) and \(y\) both satisfied
\[
\text{count}(x) > \frac{m}{2}, \quad \text{count}(y) > \frac{m}{2},
\]
then \(\text{count}(x)+\text{count}(y) > m\), impossible.  
So every non-diverse substring has **exactly one** strict majority letter.

Therefore, the sets
\[
M_c = \{\text{substrings where } c \text{ is strict majority}\}
\]
are disjoint over all \(c\in\{a,\dots,z\}\), and:
\[
\#(\text{diverse}) = \#(\text{all substrings}) - \sum_c |M_c|.
\]
Also note: substrings of length 1 are never diverse (since \(1 > \frac{1}{2}\)), and they are correctly counted in exactly one \(M_c\).

### 2) Counting \(|M_c|\) for a fixed letter \(c\)
Create an array \(a\) of length \(n\):
- \(a_i = +1\) if \(s_i = c\),
- \(a_i = -1\) otherwise.

For a substring of length \(m\), let \(\#c\) be the number of occurrences of \(c\). Its sum is:
\[
S = \#c - (m-\#c) = 2\#c - m.
\]
Then \(c\) is a strict majority iff \(\#c > \frac{m}{2}\), which is equivalent to:
\[
2\#c - m > 0 \iff S > 0.
\]
So \(|M_c|\) equals the number of subarrays with **positive sum** in this \(\pm 1\) array.

Let prefix sums be \(P_0=0\), \(P_k=\sum_{i=1}^k a_i\). A subarray \((l..r)\) has sum \(>0\) iff:
\[
P_r - P_{l-1} > 0 \iff P_{l-1} < P_r.
\]
So we must count pairs \((i<j)\) such that \(P_i < P_j\).

Prefix sums lie in \([-n,n]\), so we can coordinate-map them by shifting with an offset and use a Fenwick tree (BIT) to maintain counts of seen prefix sums:
- when at \(P_j\), the number of earlier \(P_i < P_j\) is the BIT prefix query up to \(P_j-1\).

### 3) Complexity
We do this for 26 letters:
- Time: \(O(26 \cdot n \log n)\)
- Memory: \(O(n)\)

---

## C++17 Reference Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Fenwick {
    int n;
    vector<long long> bit;
    Fenwick(int n = 0) { init(n); }
    void init(int n_) {
        n = n_;
        bit.assign(n + 1, 0);
    }
    void add(int i, long long v) {
        for (; i <= n; i += i & -i) bit[i] += v;
    }
    long long sumPrefix(int i) const {
        long long r = 0;
        for (; i > 0; i -= i & -i) r += bit[i];
        return r;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    string s;
    cin >> n >> s;

    long long totalSubstrings = 1LL * n * (n + 1) / 2;

    // Prefix sums are in [-n, n]. Map x -> x + offset (1-based indexing).
    int offset = n + 2;        // ensures minimum index >= 1
    int SZ = 2 * n + 5;        // enough for indices up to 2n+2

    Fenwick fw(SZ);
    long long majorityTotal = 0;

    for (char c = 'a'; c <= 'z'; c++) {
        fw.init(SZ);
        int pref = 0;

        // Insert prefix sum P0 = 0
        fw.add(pref + offset, 1);

        long long cntPositive = 0;
        for (int i = 0; i < n; i++) {
            pref += (s[i] == c ? 1 : -1);
            int idx = pref + offset;

            // Count previous prefix sums strictly less than current: P_i < P_j
            cntPositive += fw.sumPrefix(idx - 1);

            fw.add(idx, 1);
        }
        majorityTotal += cntPositive;
    }

    long long diverse = totalSubstrings - majorityTotal;
    cout << diverse << "\n";
    return 0;
}
```